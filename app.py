import os
from flask import Flask, request, render_template, send_file, redirect, url_for, flash
import pandas as pd
import re
from datetime import datetime
import openpyxl

app = Flask(__name__)
app.secret_key = 'some_secret_key'

UPLOAD_FOLDER = 'uploads'
PROCESSED_FOLDER = 'processed'
CSV_PATH = 'clients.csv'

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(PROCESSED_FOLDER, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['PROCESSED_FOLDER'] = PROCESSED_FOLDER

people = [
    {"Lead generated by": "Aditya Tiger", "lead Assigned to": "chintutiger724@gmail.com"},
    {"Lead generated by": "Sunita Yadav", "lead Assigned to": "sunitayadav.uk@gmail.com"},
    {"Lead generated by": "girish mishra", "lead Assigned to": "mishra.girish196@gmail.com"},
]

def parse_lead_text(lead_text):
    """
    Parse lead text to extract names and phone numbers.
    Expected format: "Hi User, Name, IND  91-XXXXXXXXXX is looking for..." or "Hi User, Name, 91-XXXXXXXXXX is interested in..."
    """
    leads = []
    
    # Split by "Hi User," to get individual leads
    lead_parts = lead_text.split("Hi User,")
    
    for part in lead_parts:
        if not part.strip():
            continue
            
        # Extract name - look for text after first comma and before "IND" or phone number pattern
        # Handle cases like "Anil, IND" or "NEERAJKANDHARI, 91-" or "Amit vikram singh, IND"
        name_match = re.search(r'^\s*([^,]+?)(?:,\s*(?:IND\s+)?91-|\s+91-)', part)
        if name_match:
            name = name_match.group(1).strip()
            
            # Extract phone number (remove +91 prefix and any formatting)
            phone_match = re.search(r'91[-\s]*(\d{10})', part)
            if phone_match:
                phone = phone_match.group(1)
                leads.append({
                    'name': name,
                    'phone': phone
                })
    
    return leads

def clean_phone_number(num):
    if pd.isna(num):
        return num
    num_str = str(num).strip()
    if 'e' in num_str.lower():
        try:
            num_str = str(int(float(num_str)))
        except:
            pass
    num_str = re.sub(r'^\\+91\\s*', '', num_str)
    return num_str.strip()

def is_blank(val):
    if pd.isna(val):
        return True
    if isinstance(val, str) and val.strip() == '':
        return True
    return False

def blank_unnamed_headers(df):
    new_columns = []
    for col in df.columns:
        if isinstance(col, str) and col.startswith('Unnamed'):
            new_columns.append('')
        else:
            new_columns.append(col)
    df.columns = new_columns

def client_rows_mask(df, client_fields):
    return ~df[client_fields].applymap(is_blank).all(axis=1)

def last_non_blank(series: pd.Series):
    """Return last non-blank value from a Series or '' if none."""
    if series is None:
        return ''
    non_blank = series[~series.apply(is_blank)]
    return non_blank.iloc[-1] if not non_blank.empty else ''

def get_project_col(df: pd.DataFrame):
    """Return the correct Project column name if present."""
    if 'Project Interested In' in df.columns:
        return 'Project Interested In'
    if 'Project Interested' in df.columns:
        return 'Project Interested'
    return None

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        lead_text = request.form.get('lead_text', '').strip()
        excel_files = request.files.getlist('excel_files')
        selected_people = request.form.getlist('selected_people')

        if not selected_people:
            flash("Please select at least one person to assign leads to.")
            return redirect(request.url)

        if lead_text:
            parsed_leads = parse_lead_text(lead_text)
            if not parsed_leads:
                flash("No valid leads found in the text. Please check the format.")
                return redirect(request.url)
            
            processed_csv_path = process_lead_text(CSV_PATH, parsed_leads, selected_people)
            return send_file(processed_csv_path, as_attachment=True)
        
        # Original Excel file processing
        elif excel_files and not all(f.filename == '' for f in excel_files):
            excel_paths = []
            for ef in excel_files:
                if ef and ef.filename != '':
                    path = os.path.join(app.config['UPLOAD_FOLDER'], ef.filename)
                    ef.save(path)
                    excel_paths.append(path)

            processed_csv_path = process_files(CSV_PATH, excel_paths, selected_people)
            return send_file(processed_csv_path, as_attachment=True)
        else:
            flash("Please upload Excel files or provide lead text!")
            return redirect(request.url)

    return render_template('index.html', people=people)

def process_lead_text(csv_file, parsed_leads, selected_people):
    """Process parsed leads and create CSV file"""
    df_csv = pd.read_csv(csv_file, dtype=str)
    df_csv.reset_index(drop=True, inplace=True)

    # Remove rows that are completely blank across all important columns
    client_fields = ['Client Name', 'Client Email', 'Client Number', 'Client Address']
    important_cols = client_fields + ['Group', 'Remark', 'Lead Source', 'Project Interested In']
    completely_blank_mask = df_csv[important_cols].applymap(is_blank).all(axis=1)
    df_csv = df_csv[~completely_blank_mask].reset_index(drop=True)

    # Create DataFrame from parsed leads
    lead_data = []
    for lead in parsed_leads:
        lead_data.append({
            'Client Name': lead['name'],
            'Client Number': lead['phone'],
            'Client Email': '',
            'Client Address': 'Noida'
        })
    df_leads = pd.DataFrame(lead_data)

    blank_rows_mask = df_csv[client_fields].applymap(is_blank).all(axis=1)
    blank_row_indices = df_csv.index[blank_rows_mask].tolist()

    # Fill blank rows with lead data
    idx_leads = 0
    for idx in blank_row_indices:
        if idx_leads < len(df_leads):
            for col in client_fields:
                if col in df_leads.columns:
                    df_csv.at[idx, col] = df_leads.at[idx_leads, col]
            idx_leads += 1
        else:
            break

    if idx_leads < len(df_leads):
        leftover = df_leads.iloc[idx_leads:]
        # Initialize empty row with all df_csv columns
        project_col = get_project_col(df_csv)
        meta_cols = ['Group', 'Remark', 'Lead Source'] + ([project_col] if project_col else [])
        for _, lead_row in leftover.iterrows():
            new_row = {col: '' for col in df_csv.columns}
            # Fill client data
            for col in client_fields:
                if col in lead_row:
                    new_row[col] = lead_row[col]
            # Drag meta fields from last non-blank values in df_csv
            for mcol in meta_cols:
                if mcol:
                    new_row[mcol] = last_non_blank(df_csv[mcol]) if mcol in df_csv.columns else ''
            df_csv = pd.concat([df_csv, pd.DataFrame([new_row])], ignore_index=True)

    # Recompute and drop completely blank rows (safety)
    completely_blank_mask = df_csv[important_cols].applymap(is_blank).all(axis=1)
    df_csv = df_csv[~completely_blank_mask].reset_index(drop=True)

    # Compute mask of rows that actually contain a client
    valid_rows_mask = client_rows_mask(df_csv, client_fields)

    # Set date only for rows with a client
    today_str = datetime.today().strftime('%Y-%m-%d')
    df_csv.loc[valid_rows_mask, 'Lead Date'] = today_str

    project_col = get_project_col(df_csv)
    cols_to_fill = ['Group', 'Remark', 'Lead Source'] + ([project_col] if project_col else [])
    for col in cols_to_fill:
        if col and col in df_csv.columns:
            mask_blank = valid_rows_mask & df_csv[col].apply(is_blank)
            df_csv.loc[mask_blank, col] = df_csv[col].ffill()[mask_blank]

    # Default address only where client row is present and address blank
    if 'Client Address' in df_csv.columns:
        df_csv.loc[valid_rows_mask, 'Client Address'] = df_csv.loc[valid_rows_mask, 'Client Address'].apply(
            lambda x: 'Noida' if is_blank(x) else x
        )

    # Assign leads only across rows that have a client
    selected_people = [p for p in people if p["Lead generated by"] in selected_people]
    total_people = len(selected_people)
    if total_people > 0:
        client_indices = df_csv.index[valid_rows_mask].tolist()
        for i, row_idx in enumerate(client_indices):
            person = selected_people[i % total_people]
            df_csv.at[row_idx, 'Lead generated by'] = person["Lead generated by"]
            df_csv.at[row_idx, 'lead Assigned to'] = person["lead Assigned to"]

    # Drop any non-client rows
    df_csv = df_csv[valid_rows_mask].reset_index(drop=True)

    blank_unnamed_headers(df_csv)

    # Save processed file (unchanged)
    date_str = datetime.today().strftime('%Y-%m-%d')
    base_name = f"coworkingnetwork_{date_str}.csv"
    save_path = os.path.join(app.config['PROCESSED_FOLDER'], base_name)

    if os.path.exists(save_path):
        i = 1
        while True:
            new_name = f"coworkingnetwork_{date_str}_{i}.csv"
            new_path = os.path.join(app.config['PROCESSED_FOLDER'], new_name)
            if not os.path.exists(new_path):
                save_path = new_path
                break
            i += 1

    df_csv.to_csv(save_path, index=False)
    return save_path

def process_files(csv_file, excel_files, selected_people):
    df_csv = pd.read_csv(csv_file, dtype=str)
    df_csv.reset_index(drop=True, inplace=True)

    excel_dataframes = []
    for file in excel_files:
        df_excel = pd.read_excel(file, engine='openpyxl', dtype=str)
        df_excel.reset_index(drop=True, inplace=True)
        blank_unnamed_headers(df_excel)
        df_mapped = df_excel.rename(columns={
            'full_name': 'Client Name',
            'email': 'Client Email',
            'phone_number': 'Client Number',
            'city': 'Client Address'
        })
        available_cols = [col for col in ['Client Name', 'Client Email', 'Client Number', 'Client Address'] if col in df_mapped.columns]
        df_mapped = df_mapped[available_cols]
        if 'Client Number' in df_mapped.columns:
            df_mapped['Client Number'] = df_mapped['Client Number'].apply(clean_phone_number)
        excel_dataframes.append(df_mapped)

    df_combined = pd.concat(excel_dataframes, ignore_index=True) if excel_dataframes else pd.DataFrame()

    client_fields = ['Client Name', 'Client Email', 'Client Number', 'Client Address']

    # Remove rows that are completely blank across all important columns
    important_cols = client_fields + ['Group', 'Remark', 'Lead Source', 'Project Interested In']
    completely_blank_mask = df_csv[important_cols].applymap(is_blank).all(axis=1)
    df_csv = df_csv[~completely_blank_mask].reset_index(drop=True)

    blank_rows_mask = df_csv[client_fields].applymap(is_blank).all(axis=1)
    blank_row_indices = df_csv.index[blank_rows_mask].tolist()

    idx_combined = 0
    for idx in blank_row_indices:
        if idx_combined < len(df_combined):
            for col in client_fields:
                if col in df_combined.columns:
                    df_csv.at[idx, col] = df_combined.at[idx_combined, col]
            idx_combined += 1
        else:
            break

    if idx_combined < len(df_combined):
        leftover = df_combined.iloc[idx_combined:]
        extra_cols = [col for col in df_csv.columns if col not in client_fields]
        extra_data = pd.DataFrame(index=leftover.index, columns=extra_cols)
        new_rows = pd.concat([extra_data, leftover], axis=1)

        project_col = get_project_col(df_csv)
        meta_cols = ['Group', 'Remark', 'Lead Source'] + ([project_col] if project_col else [])
        for mcol in meta_cols:
            if mcol and mcol in new_rows.columns:
                new_rows[mcol] = last_non_blank(df_csv[mcol]) if mcol in df_csv.columns else ''

        df_csv = pd.concat([df_csv, new_rows], ignore_index=True)

    # Compute mask of rows that actually contain a client
    valid_rows_mask = client_rows_mask(df_csv, client_fields)

    # Set date only for rows with a client
    today_str = datetime.today().strftime('%Y-%m-%d')
    df_csv.loc[valid_rows_mask, 'Lead Date'] = today_str

    # Ensure Client Address only on client rows
    if 'Client Address' in df_csv.columns:
        df_csv.loc[valid_rows_mask, 'Client Address'] = df_csv.loc[valid_rows_mask, 'Client Address'].apply(
            lambda x: 'Noida' if is_blank(x) else x
        )

    project_col = get_project_col(df_csv)
    cols_to_fill = ['Group', 'Remark', 'Lead Source'] + ([project_col] if project_col else [])
    for col in cols_to_fill:
        if col and col in df_csv.columns:
            mask_blank = valid_rows_mask & df_csv[col].apply(is_blank)
            df_csv.loc[mask_blank, col] = df_csv[col].ffill()[mask_blank]

    # Assign leads only across rows that have a client
    selected_people = [p for p in people if p["Lead generated by"] in selected_people]
    total_people = len(selected_people)
    if total_people > 0:
        client_indices = df_csv.index[valid_rows_mask].tolist()
        for i, row_idx in enumerate(client_indices):
            person = selected_people[i % total_people]
            df_csv.at[row_idx, 'Lead generated by'] = person["Lead generated by"]
            df_csv.at[row_idx, 'lead Assigned to'] = person["lead Assigned to"]

    # Drop any non-client rows
    df_csv = df_csv[valid_rows_mask].reset_index(drop=True)

    blank_unnamed_headers(df_csv)

    # Save file (unchanged)
    date_str = datetime.today().strftime('%Y-%m-%d')
    base_name = f"coworkingnetwork_{date_str}.csv"
    save_path = os.path.join(app.config['PROCESSED_FOLDER'], base_name)

    if os.path.exists(save_path):
        i = 1
        while True:
            new_name = f"coworkingnetwork_{date_str}_{i}.csv"
            new_path = os.path.join(app.config['PROCESSED_FOLDER'], new_name)
            if not os.path.exists(new_path):
                save_path = new_path
                break
            i += 1

    df_csv.to_csv(save_path, index=False)
    return save_path

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)
